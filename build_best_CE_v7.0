#! /bin/csh

# Written by Jason Bray, July 8, 2010
# Version 7.0 last updated by Jason Bray, January 19, 2012
# New features in version 7
#   1) -testset flag will automatically set the -eci flag, then at each step use the current
#   eci's to predict energies of the test set structures, which much be stored in a directory
#   named testset. These predicted energies are simply stored while the cv score minimization 
#   is running, and at the end, a report is made comparing the rms errors of the test set at 
#   each step in the optimization, allowing the user to make the decision of which set of eci's
#   to ultimately use.  By default the eci's leading to the lowest rms value will be recommended
#   rather than the lowest cv score.
#   2) -pa allows energies to be defined in units of eV/atom rather than eV/supercell as is usually 
#   the case with VASP

# Version 6.1 last updated by Jason Bray, February 25, 2011
# New features in version 6
#   1) -eci flag will calculate eci's after every step and then compile all of the eci's
#   into a summary file at the end.  Allows the user to observe whether or not the
#   coefficients are converging as the optimization progresses.
#   2) -o flag allows user to change the name of the output file from the default (build_best_CE.out)
#   3) .cluster_cost output file giving a clue to the relative importance of each cluster in CE
#   4) -nclus flag allows user to set the max number of clusters to include in the CE
#   5) write getclus.out file
#   6) use lsfit instead of clusterexpand to generate eci's, which is much faster

# This script is designed to sequentially build a cluster expansion by either
# adding or removing every cluster in clusters.out one at a time from the existing
# cluster expansion to see which gives the best cv score.
# That best cluster is then either added or removed and the process repeats.
# At the end of each loop the ECI's are calculated and stored for subsequent analysis
# This continues as one cluster is chosen and added to or removed from the cluster expansion
# until the cv score no longer improves with the addition or removal of clusters.

# This script proceeds as follows:
#  1. Determine important parameters, such as how many total clusters.
#  2. Set up initial cluster expansion.  This allows a command line option "-seed"
#     which will look for a file called .included_clusters_initial which
#     should contain a list (in a column, one cluster per line) of the
#     clusters to use in the initial CE
#  3. Outer loop compares the newest fit with the previous fit to ensure the
#     cv score is decreasing.  If cv score is not less than or equal to the previous
#     fit, then the script ends.
#  4. Inner loop cycles through all clusters and tests the fit with each cluster (one at a time)
#     switched from on to off or from off to on.  The cluster that generates the lowest
#     cv score when switched is then added to or removed from the cluster expansion.  ECI's
#     are then calculated and saved.
#  5. Check if loop ended because all clusters were used up (as opposed to reaching convergence).
#  6. Recalculate cv score, determine ECI's (via clusterexpand), predict energies of
#     all structures present in directory (via myFit.csh and clusterpredict), and print out results.

# The following scripts and codes are called directly by this script and must be in the path:
#   lsfit - part of the ATAT package, determines cv score and ECI's for a specified CE
#   clusterexpand - part of the ATAT package, calculates ECI's for the specified CE
#   myFit.csh - code written by David Schmidt and modified by Jason Bray, obtains predicted energies
#      for all structures present in directory where script is called
#   clusterpredict - part of the ATAT, uses CE to predict energy, used by myFit.csh

# The following scripts and codes are needed indirectly by the script, primarily to generate certain files used by the script:
#   corrdump - part of ATAT, used to generate list of clusters in clusters.out

# The following files must exist as input in the same directory where the script is called:
#   lat.in - contains structure information about system, used to know number of sites and total atoms
#   clusters.out - generated prior to executing this script by corrdump, contains all possible clusters
#      that can be used to build CE
#   allcorr.out - generated prior to executing this script by clusterexpand, contains encoded
#      information about cluster expansion, used as input for lsfit
#   allenergy.out - generated prior to executing this script by clusterexpand, contains energy
#      of all structures present in directory where script is called, used as input for lsfit
#   clusmult.out - only when using "-eci" option, generated by clusterexpand, contains multiplication
#      factors to convert ecimult to eci.  See code for clusterexpand for more details.
#   .included_clusters_seed - (optional) if "-seed" option is used, this file is read to initialize
#      the CE before the optimization algorithm begins; must be a single column of numbers, 1 number per line

# The following files are created as output by this script and can be found in the directory where it is called:
#   build_best_CE.out (default) - contains step by step record of the fitting process, including which clusters
#      were included in which expansions, which were added and removed, and how the cv score changed
#   .included_clusters - list of which clusters (numbered according to clusters.out file)
#      were included in the best CE, listed in order of addition during execution of the script
#   .cv_final - cv score (per site) of the best CE
#   .cv_initial - cv score (per atom) of the original CE prior to beginning optimization algorithm
#   .cv_tmp - cv score (per atom) generated throughout optimization for comparison
#   .CE_final - representation of best CE using 1's and 0's
#   .cluster_cost - for each cluster in .included_clusters, reports the cv score that would result if that cluster
#      were removed from the cluster expansion.  Should give an indication of the relative importance of each cluster.
#   myFit.out - output from myFit.csh containing DFT energies and predicted CE energies for all
#      structures present in directory where script is called
#   energy.eci and energy.ecimult - generated as output by clusterexpand code, renamed as fit.eci and fit.ecimult
#   fit.eci and fit.ecimult - renamed from energy.eci and energy.ecimult, output from clusterexpand code,
#      used by myFit.csh via clusterpredict code
#   getclus.out - 1st column: number of cluster in clusters.out, 2nd column: cluster type (pair, triplet, etc.), 
#      3rd column: cluster radius, 4th column: multiplicity, 5th column: eci's, 6th column: ecimult's
#   testset.out - file containing the prediction errors of each test set structure and the rms average error of 
#      all structures for each step of the cv score optimization



#################################################################################
#  0. Scan user input to determine selected options and associated values.  Check
#     for key files and exit if they do not exist.
#################################################################################

set eciflag = 0
set outputflag = 0
set nclus_max_flag = 0
set seedflag = 0
set testset_flag = 0
set per_atom = false
while ( $#argv != 0 )
  switch ($1)
    case "-o":
        set outputflag = 1
	set MAIN_OUTPUT = $2
	shift
    breaksw
    case "-eci":
        set eciflag = 1
    breaksw
    case "-seed":
        set seedflag = 1
    breaksw
    case "-nclus":
        set nclus_max_flag = 1
	set nclus_max = $2
	shift
    breaksw
    case "-testset":
	set testset_flag = 1
	set eciflag = 1
    breaksw
    case "-pa":
	set per_atom = true
    breaksw
    default:
        break
  endsw
  shift
end

# echo all flags for testing purposes
#echo eciflag: $eciflag
#echo nclus_max_flag: $nclus_max_flag
#echo outputflag: $outputflag
#echo seedflag: $seedflag
#echo testset_flag: $testset_flag

# run clusterexpand to generate allcorr.out, allenergy.out, and clusmult.out files
echo -n Running clusterexpand. . . 
if ($per_atom == true) then
    clusterexpand -pa energy
else
    clusterexpand energy
endif
echo done

# send error if critical files are missing
if (! -e clusters.out) then
    echo Missing clusters.out file.  Please run corrdump to generate this file.  Ending script.
    exit 0
endif

if (! -e lat.in) then
    echo Missing lat.in file.  Ending script.
    exit 0
endif

if (! -e allcorr.out) then
    echo Missing allcorr.out file.  Please run clusterexpand to generate this file.  Ending script.
    exit 0
endif

if (! -e allenergy.out) then
    echo Missing allenergy.out file.  Please run clusterexpand to generate this file.  Ending script.
    exit 0
endif


# set up output files

if ($outputflag == 0) set MAIN_OUTPUT = build_best_CE.out #default

set ECI_COLUMN_OUTPUT = b-b-CE_ECI_column.dat # contains each cluster's ECIs as a row, with each iteration step as a column
set ECI_ROW_OUTPUT = b-b-CE_ECI_row.dat # contains each cluster's ECIs as a column, with each iteration step as a row. should be easier to plot with gnuplot or excel
set ECIMULT_COLUMN_OUTPUT = b-b-CE_ECIMULT_column.dat
set ECIMULT_ROW_OUTPUT = b-b-CE_ECIMULT_row.dat
set TMPDIR = tmpECI
set TESTSET_REPORT = testset.out
set TESTDIR = testset_structures
echo Output from build_best_cluster_expansion script run on `date` >! $MAIN_OUTPUT
echo >> $MAIN_OUTPUT
echo build_best_CE script started: `date`


##################################################################################
#  1. Determine parameters used later in script.
##################################################################################

# determine how many clusters are in clusters.out
set totclusters = `grep -x "" clusters.out | wc -l`
echo $totclusters total clusters available in clusters.out >> $MAIN_OUTPUT
set ten_percent = `echo "( $totclusters - ( $totclusters % 10 ) ) / 10" | bc` 
if ($nclus_max_flag == 1) then
    echo Maximum number of clusters permitted in CE set by user to $nclus_max >> $MAIN_OUTPUT
else
    set nclus_max = $totclusters # apply default
endif

# determine number of structures being used to fit cluster expansion
set totstructures = `ls */energy | wc -l`
echo $totstructures structures used in fit >> $MAIN_OUTPUT

# determine number of test set structures
if ($testset_flag == 1) then
    set ntest_str = `ls $TESTDIR/*/energy | wc -l`
    echo Report of prediction errors for test set >! $TESTSET_REPORT
    echo >> $TESTSET_REPORT
    echo "Step #\t\t[Prediction Error of $ntest_str Test Set Structures...]\t\tRMS Prediction Error" >> $TESTSET_REPORT
    echo -------------------------------------------------------------------------------------------------------------- >> $TESTSET_REPORT
    echo $ntest_str test set structures used to evaluate fit >> $MAIN_OUTPUT
endif

# determine number of sites (can have adsorbate or vacancy) and total atoms in lat.in
set totsites = `grep "," lat.in | wc -l`
set totatoms = `grep "[A-Z]" lat.in | wc -l`
echo $totatoms atoms total, $totsites of which are involved in cluster expansion >> $MAIN_OUTPUT
echo >> $MAIN_OUTPUT

if ($totstructures < $totsites) then
    echo Not enough structures available to fit CE.  Ending script.
    exit 0
endif


##################################################################################
#  2. Set up initial cluster expansion with only zero- and single-body clusters
#     or with seed cluster expansion provided by user and find initial cv score.
##################################################################################

# set up a few variables
@ nclus_init = $totsites + 1
@ first_new_cluster = $nclus_init + 1
set included_clusters = () # array to store cluster numbers of clusters included in expansion
set unused_clusters = () # array to store clusters that are not being used in expansion
 
# decide which clusters to use initially, write to included_clusters array
if ($seedflag == 1) then
    if (-e .included_clusters_seed) then
	# initialize cluster expansion using optional seed .included_clusters_seed file
	set included_clusters = `cat .included_clusters_seed | tr "\n" " "`
    else
	echo Could not find .included_clusters_seed. Please remove the -seed option or create this file and try again.
	exit 0
    endif
else # apply default of only zero- and single-body clusters
   set i = 1
    while ($i <= $nclus_init)
	set included_clusters = ($included_clusters $i)
	@ i++
    end
endif

# initialize the cluster expansion with only those listed in included_clusters array
set CE = () # array with 1's for clusters used and 0's for clusters not used in fit
set i = 1
while ($i <= $totclusters)
    set useclus = 0
    set j = 1
    while ($j <= $#included_clusters)
	if ($i == $included_clusters[$j]) set useclus = 1
	@ j++
    end
    set CE = ($CE $useclus)
    if ($useclus == 0) set unused_clusters = ($unused_clusters $i)
    @ i++
end

# find cv score of initial cluster expansion
# lsfit (least-squares fit) is part of the ATAT package
set ce_comma_delim = `echo $CE | tr " " ","`
lsfit -cv -x=allcorr.out -y=allenergy.out -s=$ce_comma_delim >! .cv_initial
grep -q "e" .cv_initial # check for overflow cv score with value of 3.4e+38
if ($status == 0) then # if grep finds "e+" $status = 0, if not then $status = 1
    set cv_initial_per_atom = `cat .cv_initial | tr "e" "^" | tr "+" " " ` # replace e+ with ^, + with a blank space
else
    set cv_initial_per_atom = `cat .cv_initial`
endif
#set cv_initial_per_atom = `cat .cv_initial`
set cv_initial_per_site = `echo "scale=7; $cv_initial_per_atom * $totatoms / $totsites" | bc`
if ($seedflag == 1) then
    echo Initial cv score using seed clusters: >> $MAIN_OUTPUT
else
    echo Initial cv score with only zero- and single-body clusters included: >> $MAIN_OUTPUT
endif
echo $cv_initial_per_atom eV per atom >> $MAIN_OUTPUT
echo $cv_initial_per_site eV per site >> $MAIN_OUTPUT
echo >> $MAIN_OUTPUT
set cv_old = 999 # $cv_initial_per_site # keeps track of previous cv score for comparison
#set cv_old_convergence_test = $cv_initial_per_site
set cv_new = $cv_initial_per_site
set cv_min = $cv_initial_per_site

# check for -eci option and calculate initial ECIs
mkdir -p $TMPDIR
# write cluster numbers down first column of output file
echo 'Cluster #' >! $TMPDIR/cluster_numbers
set i = 1
while ($i <= $totclusters)
	echo "$i\t" >> $TMPDIR/cluster_numbers
	@ i++
end
set eci_filelist = (cluster_numbers)
set ecimult_filelist = (cluster_numbers)


if ($eciflag == 1) then
    # calculate initial ECIs and add to filelist
    echo -n calculating initial ECIs... >> $MAIN_OUTPUT
    echo -n calculating initial ECIs...
    lsfit -x=allcorr.out -y=allenergy.out -s=$ce_comma_delim >! initial.ecimult
    if (! -e clusmult.out) then
	echo Could not find clusmult.out file.  Run clusterexpand to generate this file.  Stopping script.
	exit 0
    endif
    # line stolen from clusterexpand script of ATAT
    awk 'BEGIN {while (getline < "clusmult.out") {c++; m[c]=$1;} maxc=c; c=0;} {if ($1 != "") {c++; print $1/m[c]} else {c=0; print ""}}' initial.ecimult >! initial.eci
    echo 0 >! $TMPDIR/initial.eci
    echo 0 >! $TMPDIR/initial.ecimult
    cat initial.eci >> $TMPDIR/initial.eci
    cat initial.ecimult >> $TMPDIR/initial.ecimult
    set eci_filelist = ($eci_filelist initial.eci)
    set ecimult_filelist = ($ecimult_filelist initial.ecimult)
#    paste -s $ECI_OUTPUT .eci_tmp >! .eci_output.tmp
#    mv -f .eci_output.tmp $ECI_OUTPUT
#    paste -s $ECIMULT_OUTPUT .ecimult_tmp >! .ecimult_output.tmp
#    mv -f .ecimult_output.tmp $ECIMULT_OUTPUT
    echo done >> $MAIN_OUTPUT
    echo >> $MAIN_OUTPUT
    echo done 
    echo
endif

if ($testset_flag == 1) then
    # calculate initial rms of test set structures
    echo -n calculating predicted energies for test set... >> $MAIN_OUTPUT
    echo -n calculating predicted energies for test set... 
    cp clusters.out lat.in ref_energy.in $TESTDIR
    cp initial.eci $TESTDIR/fit.eci
    cp initial.ecimult $TESTDIR/fit.ecimult
    cd $TESTDIR
    myFit.csh
    set errors = (`cut -d " " -f 10 myFit.out | tr "\n" "\t"`)
    cd ..
    #calculate rms error
    @ a = 1
    set sumsq = 0
    set sq_errors = ()
    # calculate the sum of squares of the errors
    while ($a <= $ntest_str)
        set sq_errors = ($sq_errors `echo "$errors[$a] ^ 2" | bc -l`)
        set sumsq = `echo "$sumsq + $sq_errors[$a]" | bc -l`
        @ a++
    end
    # calculate the root mean square
    set rms = `echo "sqrt ( $sumsq / $ntest_str )" | bc -l`
    set rms_errors = ($rms)
    echo "0\t$errors\t$rms" >> $TESTSET_REPORT
    echo done >> $MAIN_OUTPUT
    echo done
    echo initial rms error of test set: $rms eV/site >> $MAIN_OUTPUT
    echo initial rms error of test set: $rms eV/site
    echo >> $MAIN_OUTPUT
    echo
endif

set cvscore_list = ($cv_initial_per_site)  # list to store cv scores for each optimization step
set nclus_list = ($#included_clusters)  # list to store the number of clusters in CE for each optimization step


##################################################################################
#  3. While loop to add or remove clusters to or from CE to improve the cv score.
#     Loop continues until new cv score is greater than old cv score or all
#     clusters have been used
##################################################################################

echo Beginning cycles of increasing and decreasing cluster expansion size >> $MAIN_OUTPUT
echo Beginning cycles of increasing and decreasing cluster expansion size
echo >> $MAIN_OUTPUT
echo
set m = 0
#if ($m != 0) then # for debugging end of script
while (`echo "$cv_new < $cv_old" | bc` == 1 && $#included_clusters < $nclus_max)
#while ($m < 2) # for debugging
    @ m++
    set cv_old = $cv_new

    echo "##############################################################" >> $MAIN_OUTPUT
    echo "##############################################################" >> $MAIN_OUTPUT
    echo Beginning cycle $m of changing cluster expansion size >> $MAIN_OUTPUT

    echo ---------------------------------------------------------------
    echo Beginning cycle $m of changing cluster expansion size

    echo $#included_clusters / $totclusters clusters in current CE >> $MAIN_OUTPUT
    echo Included clusters: $included_clusters >> $MAIN_OUTPUT
    echo Current cv score = $cv_old >> $MAIN_OUTPUT
    echo >> $MAIN_OUTPUT

    echo $#included_clusters / $totclusters clusters in current CE
    echo Current included clusters: $included_clusters
    echo Current cv score = $cv_old
    echo -n Progress through cycle $m


    ##################################################################################
    #  4. Inner while loop cycles through every cluster one at a time and changes
    #     whether or not it is included in the CE and calculates the cv score.  The
    #     cluster that generates the lowest cv score when switched is tracked and
    #     identified so that it can be added to or removed from the cluster expansion
    #     after the loop has completed.
    ##################################################################################

    set i = 1
    echo Beginning loop through $totclusters clusters... >> $MAIN_OUTPUT
    echo >> $MAIN_OUTPUT
    while ($i <= $totclusters) #foreach cluster ($unused_clusters)
	if ($CE[$i] == 1) then
	    set CE[$i] = 0
    
	    set ce_comma_delim = `echo $CE | tr " " ","`
	    lsfit -cv -x=allcorr.out -y=allenergy.out -s=$ce_comma_delim >! .cv_tmp
	    grep -q "e" .cv_tmp # check for overflow cv score with value of 3.4e+38
	    if ($status == 0) then # if grep finds "e+" $status = 0, if not then $status = 1
		set cv_tmp_per_atom = `cat .cv_tmp | tr "e" "^" | tr "+" " "` # replace e+ with ^
	    else
		set cv_tmp_per_atom = `cat .cv_tmp`
	    endif
	    set cv_tmp = `echo "scale=7; ( $cv_tmp_per_atom ) * ( $totatoms / $totsites )" | bc `

	    set CE[$i] = 1
	else
	    set CE[$i] = 1
    
	    set ce_comma_delim = `echo $CE | tr " " ","`
	    lsfit -cv -x=allcorr.out -y=allenergy.out -s=$ce_comma_delim >! .cv_tmp
	    grep -q "e" .cv_tmp
	    if ($status == 0) then
		set cv_tmp_per_atom = `cat .cv_tmp | tr "e" "^" | tr "+" " "`
	    else
		set cv_tmp_per_atom = `cat .cv_tmp`
	    endif
	    set cv_tmp = `echo "scale=7; ( $cv_tmp_per_atom ) * ( $totatoms / $totsites )" | bc `

	    set CE[$i] = 0
	endif

        # This "|| $i = $first_new_cluster" statement serves two purposes.  1: it prevents the zero- and
	# one-body clusters from being removed from the CE, but this would realistically never happen
	# anyway.  2: it allows the algorithm to continue even in the rare case that adding or removing
	# a cluster does not actually change the cv score. It treats the first cluster after
        # zero- and one-body terms as if it were the min_cluster, so even if the cv score never decreased
	# beyond that point, it would still be able to choose a cluster to switch.
        if (`echo "$cv_tmp < $cv_min" | bc` == 1 ) then #|| $i == $first_new_cluster) then 
            echo New min cv score found with switching of cluster $i : >> $MAIN_OUTPUT
            echo $cv_tmp >> $MAIN_OUTPUT
            echo >> $MAIN_OUTPUT

	    set min_cluster = $i # the number of the cluster, to add to included_clusters array later
	    set cv_min = $cv_tmp # save the new lower cv score
        endif
    
        if (`echo "( $i % $ten_percent ) == 0" | bc` == 1) then
	    @ progress = ( $i / $ten_percent ) * 10
	    echo -n "...${progress}%" # progress bar
	endif

	@ i ++
    end # end of while loop

    
    echo End of loop >> $MAIN_OUTPUT
    echo >> $MAIN_OUTPUT
    
    if (`echo "$cv_min < $cv_old" | bc` == 1) then # 1 is true, 0 is false
	if ($CE[$min_cluster] == 1) then
	    # need to remove cluster from included_clusters array, add it to unused_clusters array, and change CE[$min_cluster] to 0
	    set i = 1
	    while ($i <= $#included_clusters)
		if ($included_clusters[$i] == $min_cluster) set min_index = $i
		@ i++
	    end

	    @ j = $min_index - 1
	    @ k = $min_index + 1
	    if ($min_index == $#included_clusters) then
		set included_clusters = ($included_clusters[1-$j]) # remove selected cluster when it is the last one in the list # this should actually never be the case
	    else
		set included_clusters = ($included_clusters[1-$j] $included_clusters[$k-]) # remove selected cluster from included_clusters list
	    endif
	    set unused_clusters = ($unused_clusters $min_cluster) # add selected cluster to unused_clusters list
	    set CE[$min_cluster] = 0 # update cluster expansion to remove selected cluster

	    echo Cluster $min_cluster removed from cluster expansion >> $MAIN_OUTPUT
	    echo
	    echo Cluster $min_cluster removed from cluster expansion
	else
	    # need to remove cluster from unused_clusters array, add it to included_clusters array, and change CE[$min_cluster] to 1
	    set i = 1
	    while ($i <= $#unused_clusters)
	        if ($unused_clusters[$i] == $min_cluster) set min_index = $i
	        @ i++
	    end

	    @ j = $min_index - 1
	    @ k = $min_index + 1
	    if ($min_index == $#unused_clusters) then
	        set unused_clusters = ($unused_clusters[1-$j]) # remove selected cluster when it is the last one in the list
	    else
	        set unused_clusters = ($unused_clusters[1-$j] $unused_clusters[$k-]) # remove selected cluster from unused_clusters list
	    endif
	    set included_clusters = ($included_clusters $min_cluster) # add selected cluster to included_clusters list
	    set CE[$min_cluster] = 1 # update cluster expansion to include selected cluster
		
	    echo Cluster $min_cluster added to cluster expansion >> $MAIN_OUTPUT
	    echo
	    echo Cluster $min_cluster added to cluster expansion
	endif
        set cv_new = $cv_min # save cv score of CE with selected cluster for comparison in while loop

	# check for -eci option
	if ($eciflag == 1) then
	    set ce_comma_delim = `echo $CE | tr " " ","`
	    echo -n calculating ECIs... >> $MAIN_OUTPUT
	    echo -n calculating ECIs...
	    lsfit -x=allcorr.out -y=allenergy.out -s=$ce_comma_delim >! tmp.ecimult
	    # line stolen from clusterexpand script of ATAT
	    awk 'BEGIN {while (getline < "clusmult.out") {c++; m[c]=$1;} maxc=c; c=0;} {if ($1 != "") {c++; print $1/m[c]} else {c=0; print ""}}' tmp.ecimult >! tmp.eci
	    echo $m >! $TMPDIR/$m.eci
	    echo $m >! $TMPDIR/$m.ecimult
	    cat tmp.eci >> $TMPDIR/$m.eci
	    cat tmp.ecimult >> $TMPDIR/$m.ecimult
	    set eci_filelist = ($eci_filelist $m.eci)
	    set ecimult_filelist = ($ecimult_filelist $m.ecimult)
	    echo done >> $MAIN_OUTPUT
	    echo >> $MAIN_OUTPUT
	    echo done
	    echo
	    if ($testset_flag == 1) then
		echo -n calculating predicted energies for test set... >> $MAIN_OUTPUT
		echo -n calculating predicted energies for test set...
		cp tmp.eci $TESTDIR/fit.eci
		cp tmp.ecimult $TESTDIR/fit.ecimult
		cd $TESTDIR
		myFit.csh
		set errors = (`cut -d " " -f 10 myFit.out | tr "\n" "\t"`)
		cd ..
		#calculate rms error
		@ a = 1
		set sumsq = 0
		set sq_errors = ()
		# calculate the sum of squares of the errors
		while ($a <= $ntest_str)
		    set sq_errors = ($sq_errors `echo "$errors[$a] ^ 2" | bc -l`)
		    set sumsq = `echo "$sumsq + $sq_errors[$a]" | bc -l`
		    @ a++
		end
		# calculate the root mean square
		set rms = `echo "sqrt ( $sumsq / $ntest_str )" | bc -l`
		set rms_errors = ($rms_errors $rms)
		echo "$m\t$errors\t$rms" >> $TESTSET_REPORT
		echo done >> $MAIN_OUTPUT
		echo done
		echo rms error of test set: $rms eV/site >> $MAIN_OUTPUT
		echo rms error of test set: $rms eV/site
		echo >> $MAIN_OUTPUT
		echo
	    endif
	endif

	set cvscore_list = ($cvscore_list $cv_new)
	set nclus_list = ($nclus_list $#included_clusters)
        echo New cv score with $#included_clusters clusters included = $cv_new
        echo Included clusters: $included_clusters
        echo
        echo CV score decreased by `echo "( $cv_old - $cv_new ) * 1000" | bc` meV per site
        echo Ending cycle $m
        echo ---------------------------------------------------------------
        echo

        echo New cluster expansion: >> $MAIN_OUTPUT
        echo $CE >> $MAIN_OUTPUT
        echo >> $MAIN_OUTPUT
        echo New cv score with $#included_clusters clusters included = $cv_new >> $MAIN_OUTPUT
        echo Included clusters: $included_clusters >> $MAIN_OUTPUT
        echo >> $MAIN_OUTPUT
        echo CV score decreased by `echo "( $cv_old - $cv_new ) * 1000" | bc` meV per site >> $MAIN_OUTPUT
        echo $#unused_clusters unused clusters remaining >> $MAIN_OUTPUT
        echo Ending cycle $m >> $MAIN_OUTPUT
        echo "##############################################################" >> $MAIN_OUTPUT
        echo "##############################################################" >> $MAIN_OUTPUT
        echo >> $MAIN_OUTPUT
    else
        echo CV score decreased by `echo "( $cv_old - $cv_min ) * 1000" | bc` meV per site >> $MAIN_OUTPUT
        echo The new minimum cv score is greater than the previous value, so cluster expansion will remain unchanged. >> $MAIN_OUTPUT
        echo $#included_clusters clusters included in cluster expansion >> $MAIN_OUTPUT
        echo CV score with $#included_clusters clusters included = $cv_old >> $MAIN_OUTPUT
        echo $#unused_clusters unused clusters remaining >> $MAIN_OUTPUT
        echo --------------------------------------------------------------- >> $MAIN_OUTPUT
        echo >> $MAIN_OUTPUT

        echo
        echo
        echo CV score did not decrease, cluster expansion will remain unchanged
        echo Ending cycle $m
        echo ---------------------------------------------------------------
        echo

        set cv_new = $cv_min
    endif
end # end of while loop to control cycles through changing cluster expansion size
#endif # for debugging

#####################################################################################
#  5. Check if loop ended because all clusters were used up.
#####################################################################################

if ($#included_clusters == $totclusters) then
    echo >> $MAIN_OUTPUT
    echo --------------------------------------------------------------- >> $MAIN_OUTPUT
    echo --------------------------------------------------------------- >> $MAIN_OUTPUT
    echo All clusters have been used. May need a wider radius of clusters to obtain best fit. >> $MAIN_OUTPUT
    echo --------------------------------------------------------------- >> $MAIN_OUTPUT
    echo --------------------------------------------------------------- >> $MAIN_OUTPUT
    echo >> $MAIN_OUTPUT
    echo
    echo All clusters have been used.  May need a wider radius of clusters to obtain best fit.
    echo
else if ($#included_clusters == $nclus_max) then
    echo >> $MAIN_OUTPUT
    echo --------------------------------------------------------------- >> $MAIN_OUTPUT
    echo --------------------------------------------------------------- >> $MAIN_OUTPUT
    echo Number of clusters has reached user-specified maximum of ${nclus_max}. >> $MAIN_OUTPUT
    echo --------------------------------------------------------------- >> $MAIN_OUTPUT
    echo --------------------------------------------------------------- >> $MAIN_OUTPUT
    echo >> $MAIN_OUTPUT
    echo
    echo Number of clusters has reached user-specified maximum of ${nclus_max}.
    echo
endif

if ($m == 0) then
    echo Script quit after $m cycles.  Problem with initial cv score too large.
    echo Initial cv score: $cv_initial_per_site eV per site
    echo
    echo Script quit after $m cycles.  Problem with initial cv score too large. >> $MAIN_OUTPUT
    echo Initial cv score: $cv_initial_per_site eV per site >> $MAIN_OUTPUT
    echo >> $MAIN_OUTPUT
endif

####################################################################################
#  6. Print out results to various files and calculate eci's and fitted energies
####################################################################################

#echo CV score is no longer decreasing. >> $MAIN_OUTPUT
echo build_best_CE script complete after $m cycles of changing cluster expansion size. >> $MAIN_OUTPUT
echo >> $MAIN_OUTPUT

# recalculate cv score for final cluster expansion
set ce_comma_delim = `echo $CE | tr " " ","`
lsfit -cv -x=allcorr.out -y=allenergy.out -s=$ce_comma_delim >! .cv_final
grep -q "e" .cv_final
if ($status == 0) then
    set cv_final_per_atom = `cat .cv_final | tr "e" "^" | tr "+" " "`
else
    set cv_final_per_atom = `cat .cv_final`
endif
set cv_final = `echo "scale=7; ( $cv_final_per_atom ) * ( $totatoms / $totsites )" | bc `

# analyze the rms prediction error for the test set structures
if ($testset_flag == 1) then
    echo analyzing the rms prediction error for the test set structures
    @ a = 1
    @ b = $#rms_errors
    set rms_min = $rms_errors[1]
    set rms_min_step = 0
    set cv_at_min_rms = $cv_initial_per_site # placeholder for step 0 cv score
    while ($a <= $b)
	@ c = $a - 1
	if (`echo "$rms_errors[$a] < $rms_min" | bc` == 1) then # 1 is true, 0 is false
	    set rms_min = $rms_errors[$a]
	    set rms_min_step = $c
	    set cv_at_min_rms = $cvscore_list[$a]
#	    echo new rms mininum at optimization step $c
	endif
	@ a++
    end
    echo minimum rms error of test set structures: $rms_min eV/site
    echo found for optimization step $rms_min_step
    echo corresponding cv score at this step: $cv_at_min_rms
    echo minimum rms error of test set structures: $rms_min eV/site >> $MAIN_OUTPUT
    echo found for optimization step $rms_min_step >> $MAIN_OUTPUT
    echo corresponding cv score at this step: $cv_at_min_rms >> $MAIN_OUTPUT
endif

@ a = 1
@ b = $#nclus_list
echo Optimization Summary
if ($testset_flag == 1) then
    echo ----------------------------------------------------------------
    echo "Step #\t# of clusters\tcv score\trms of test set"
    while ($a <= $b)
	@ c = $a - 1
	echo "Step $c\t$nclus_list[$a]\t\t$cvscore_list[$a]\t$rms_errors[$a]"
	@ a++
    end
    echo ----------------------------------------------------------------
else
    echo ------------------------------------------------
    echo "Step #\t# of clusters\tcv score"
    while ($a <= $b)
	@ c = $a - 1
	echo "Step $c\t$nclus_list[$a]\t\t$cvscore_list[$a]"
	@ a++
    end
    echo ------------------------------------------------
endif
#echo all rms values are as follows (optimization step, rms of test set structures):
echo

# calculate cv score upon removal of each included cluster, print to .cluster_cost
echo -n calculating cost to cv score of removing clusters from CE...
echo CV score with all included clusters: $cv_final eV/site >! .cluster_cost
echo >> .cluster_cost
echo "Removed Cluster\t\tCV score (eV/site)\tChange in CV score (meV/site)" >> .cluster_cost
echo "--------------------------------------------------------------------------------" >> .cluster_cost
set included_clusters_sorted = `echo $included_clusters | tr " " "\n" | sort -n`
foreach cluster ($included_clusters_sorted)
    set CE[$cluster] = 0
    set ce_comma_delim = `echo $CE | tr " " ","`
    lsfit -cv -x=allcorr.out -y=allenergy.out -s=$ce_comma_delim >! .cv_tmp
    grep -q "e" .cv_tmp # check for overflow cv score with value of 3.4e+38
    if ($status == 0) then # if grep finds "e+" $status = 0, if not then $status = 1
	set cv_tmp_per_atom = `cat .cv_tmp | tr "e" "^" | tr "+" " " ` # replace e+ with ^, + with a blank space
    else
	set cv_tmp_per_atom = `cat .cv_tmp`
    endif
    #set cv_tmp_per_atom = `cat .cv_tmp`
    set cv_tmp = `echo "scale=7; ( $cv_tmp_per_atom ) * ( $totatoms / $totsites )" | bc `
    set cv_diff = `echo "scale=7; ( ( $cv_tmp - $cv_final ) * 1000 )" | bc `
    echo "$cluster\t\t\t$cv_tmp\t\t\t$cv_diff" >> .cluster_cost
    set CE[$cluster] = 1
end
echo done
echo

# check for -eci option and combine files in filelist into one output file
if ($eciflag == 1) then
#    echo "eci_filelist = $eci_filelist"
#    echo "ecimult_filelist = $ecimult_filelist"
    cd $TMPDIR
    paste $eci_filelist >! ../$ECI_COLUMN_OUTPUT
    paste $ecimult_filelist >! ../$ECIMULT_COLUMN_OUTPUT
    paste -s $eci_filelist >! ../$ECI_ROW_OUTPUT
    paste -s $ecimult_filelist >! ../$ECIMULT_ROW_OUTPUT
    cd -
endif
# calculate eci's
echo -n calculating cluster expansion and ECIs ...
set ce_comma_delim = `echo $CE | tr " " ","`
lsfit -x=allcorr.out -y=allenergy.out -s=$ce_comma_delim >! final.ecimult
# line stolen from clusterexpand script of ATAT
awk 'BEGIN {while (getline < "clusmult.out") {c++; m[c]=$1;} maxc=c; c=0;} {if ($1 != "") {c++; print $1/m[c]} else {c=0; print ""}}' final.ecimult >! final.eci
echo done

# rename eci files for subsequent use by myFit script
rm -f fit.eci fit.ecimult
cp final.eci fit.eci
cp final.ecimult fit.ecimult
echo

# create getclus.out file containing info about clusters and eci
cat tmpECI/cluster_numbers | tail -n +2 >! clusnums.tmp
getclus final.eci >! getclus.tmp
paste clusnums.tmp getclus.tmp final.ecimult >! getclus.out
rm -f clusnums.tmp getclus.tmp

# calculate fitted energies based on eci's using myFit script
echo -n calculating fitted energies...
if ($per_atom == true) then
    myFit.csh -pa
else
    myFit.csh
endif
echo done
echo

# print results
echo $CE >! .CE_final
echo $included_clusters >! .included_clusters
echo $unused_clusters >! .unused_clusters
echo $cv_final >! .cv_final

echo ECI values found in fit.eci and fit.ecimult >> $MAIN_OUTPUT
if ($testset_flag == 1) then
    echo Test set prediction errors and rms values found in $TESTSET_REPORT >> $MAIN_OUTPUT
endif
echo Summary of clusters with eci found in getclus.out >> $MAIN_OUTPUT
echo Fitted vs. Calculated energies found in myFit.out >> $MAIN_OUTPUT
echo Final list of 1\'s and 0\'s printed to .CE_list >> $MAIN_OUTPUT
echo $CE >> $MAIN_OUTPUT
echo Final list of $#included_clusters included clusters printed to .included_clusters: >> $MAIN_OUTPUT
echo $included_clusters >> $MAIN_OUTPUT
echo Final cv score printed to .cv_final: $cv_final eV per site >> $MAIN_OUTPUT
echo Cost to cv score of removing clusters from CE printed to .cluster_cost >> $MAIN_OUTPUT
echo >> $MAIN_OUTPUT
echo Script complete: `date` >> $MAIN_OUTPUT

echo ECI values found in fit.eci and fit.ecimult
if ($testset_flag == 1) then
    echo Test set prediction errors and rms values found in $TESTSET_REPORT
endif
echo Summary of clusters with eci found in getclus.out
echo Fitted vs. Calculated energies found in myFit.out
echo Final list of 1\'s and 0\'s printed to .CE_list
echo Final list of $#included_clusters included clusters printed to .included_clusters
echo Final cv score printed to .cv_final
echo Cost to cv score of removing clusters from CE printed to .cluster_cost
echo
echo Script complete: `date`


exit 0

